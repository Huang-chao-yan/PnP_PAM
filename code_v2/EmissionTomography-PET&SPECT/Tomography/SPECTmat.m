% function [Ap,Am,A] = SPECTMatrix(s,phi,N,mu,A0)% % The program creates a sparse attenuation matrices modelling the % attenuated SPECT signal.%% The image area is the unit square [0,1]x[0,1]. The pixels are enumerated% in the same order as in matrix indexing, i.e., first pixel is in the top% left corner, the numbering proceeding columnwise.%% Each ray is parametrized by two numbers: phi is the angle between the% line and vertical axis, phi = 0 corresponding to a ray going upwards,% phi=-pi/2 going from left to right. The parameter s is the distance% of the line from the midpoint of the image with sign, so that when phi=0% and s>0, the line passes through the right half of the image. The line% can be parametrized as%% x(t) = 0.5 + s*cos(phi) - t*sin(phi)% y(t) = 0.5 + s*sin(phi) + t*cos(phi)%% Input: s   - a vector containing the s-parameters of the X-rays%        phi - a vector of same size as s containing the angles of the%              lines of incidence%        N   - integer giving pixel number per edge%        mu  - NxN array containing the discretized absorption coefficient %        A0 -  sparse matrix, preallocated memory for the sparse matrix%        structure%         % NOTE: entries of s must lie between -0.5/r and 0.5/r, where %       r = max(|sin(phi)|, |cos(phi)|), otherwise there is no%       guarantee that they hit the image area and the programme may fail.%      % Output:     Ap,Am - sparse matrices of size (k,N*N). The element Ap(i,j)%             contains the value of the integral from j:th pixel to the %             receiver at t=1 along the i;th ray. Similarly, Am(i,j) is %             the integral from the j:th pixel to the opposite receiver at%             t=0. These matrices are needed to check that none of the two%             emitted photons are absorbed before arrivin at the receivers.%             A - sparse matrix of size (k,N*N), k being the length of the%             vectors s and phi. The entry A(i,j) gives the intersection%             length of the ray i with the pixel j, weighted by the %             minimum of the integrated attenuation by the attenuation %             coefficient between the pixel and the backward and forward%             receiver2.%% Erkki Somersalo 11/17/2008%--------------------------------------------------------------------------function [A] = SPECTMatrix(s,phi,N,mu,A0)[rows,cols,vals_p] = find(A0);vals_m = vals_p;vals = vals_p;clear A0muvec = mu(:);ss = sin(phi); cc = cos(phi);K = length(s);p = 1/N*[0:N]';%ii = []; jj = []; vals = [];index = 0;waitbar(0,'Assembling the SPECT matrix ...')for k = 1:K   h=waitbar(k/K);   txy = [];   % Finding intersection points with lines y = j/N, 0<=j<=N   if abs(cc(k)) > eps      t = 1/cc(k)*(p - 0.5 - s(k)*ss(k));      x = 0.5 + s(k)*cc(k) -ss(k)*t;      aux = find((x>=0)&(x<=1));      txy = [txy;[t(aux),x(aux),p(aux)]];   end   % Finding intersection points with lines x = j/N, 0<=j<=N   if abs(ss(k)) > eps      t = 1/ss(k)*(0.5 + s(k)*cc(k) - p);      y = 0.5 + s(k)*ss(k)  + cc(k)*t;      aux = find((y>=0)&(y<=1));      txy = [txy;[t(aux),p(aux),y(aux)]];   end   % Sorting the intersection points according to increasing t   [tt,I] = sort(txy(:,1));   txy = [tt,txy(I,2),txy(I,3)];   % Computing the intersection lengths and pixels.      % If the X-ray passes from corner to corner of the pixel, the corner   % coordinates appear twice. Discarding redundant intersections   % corresponding to pairs giving zeros (or negligible) intersection length.   is = length(txy(:,1));   lengths = txy(2:is,1) - txy(1:is-1,1);   xmids = 0.5*(txy(2:is,2) + txy(1:is-1,2));   ymids = 0.5*(txy(2:is,3) + txy(1:is-1,3));   iaux = find(lengths > eps);   lengths = lengths(iaux);   xmids = xmids(iaux);   ymids = ymids(iaux);    indx = ceil(N*xmids);   indy = ceil(N*(1-ymids));   new_index = index + length(iaux);   rows(index+1:new_index) = k*ones(length(iaux),1);   pixels = (indx-1)*N+indy;   % Indices to pixels intersected by the line   cols(index+1:new_index) = pixels;   muk = muvec(pixels);   absorption = muk.*lengths;      % Pixel-wise absoptions   % Total absorption in the forward direction   cumul_absorption_p = cumsum(absorption(end:-1:1));   cumul_absorption_p = cumul_absorption_p(end:-1:1) - 0.5*absorption;   % Total absorption in the backward direction   %cumul_absorption_m = cumsum(absorption);   %cumul_absorption_m = cumul_absorption_m - 0.5*absorption;      vals_p(index+1:new_index) = cumul_absorption_p;   %vals_m(index+1:new_index) = cumul_absorption_m;   vals(index+1:new_index) = lengths.*exp(-cumul_absorption_p);   index = new_index;endclose(h)A  = sparse(rows,cols,vals,K,N*N);return