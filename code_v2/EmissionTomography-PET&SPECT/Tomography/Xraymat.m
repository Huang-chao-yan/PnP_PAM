% function A = Xraymat(s,phi,N)% % The program creates a sparse matrix A used in planar parallel beam% X-ray tomography.%% The image area is the unit square [0,1]x[0,1]. The pixels are enumerated% in the same order as in matrix indexing, i.e., first pixel is in the top% left corner, the numbering proceeding columnwise.%% Each ray is parametrized by two numbers: phi is the angle between the% line and vertical axis, phi = 0 corresponding to a ray going upwards,% phi=-pi/2 going from left to right. The parameter s is the distance% of the line from the midpoint of the image with sign, so that when phi=0% and s>0, the line passes through the right half of the image. The line% can be parametrized as%% x(t) = 0.5 + s*cos(phi) - t*sin(phi)% y(t) = 0.5 + s*sin(phi) + t*cos(phi)%% Input: s - a vector containing the s-parameters of the X-rays%        phi - a vector of same size as s containing the angles of the%        X-rays%        N - integer giving pixel number per edge%% NOTE: entries of s must lie between -0.5/r and 0.5/r, where %       r = max(|sin(phi)|, |cos(phi)|), otherwise there is no%       guarantee that they hit the image area and the programme may fail.%      % Output: A - sparse matrix of size (k,N*N), k being the length of the%             vectors s and phi. The entry A(i,j) gives the intersection%             length of the X-ray i with the pixel j.%% First version, Erkki Somersalo 10/2/2002%-------------------------------------------------------------------------- function A = XraymatAlloc(s,phi,N)% Initial memory allocation: at most 2*N pixels are cut by each rayK = length(s);rows = NaN(2*N*K,1);cols = NaN(2*N*K,1);vals = NaN(2*N*K,1);ss = sin(phi); cc = cos(phi);K = length(s);p = 1/N*[0:N]';index = 0;waitbar(0,'Assembling X-ray/tomography matrix.')for k = 1:K   h=waitbar(k/K);   txy = [];   % Finding intersection points with lines y = j/N, 0<=j<=N   if abs(cc(k)) > eps      t = 1/cc(k)*(p - 0.5 - s(k)*ss(k));      x = 0.5 + s(k)*cc(k) -ss(k)*t;      aux = find((x>=0)&(x<=1));      txy = [txy;[t(aux),x(aux),p(aux)]];   end   % Finding intersection points with lines x = j/N, 0<=j<=N   if abs(ss(k)) > eps      t = 1/ss(k)*(0.5 + s(k)*cc(k) - p);      y = 0.5 + s(k)*ss(k)  + cc(k)*t;      aux = find((y>=0)&(y<=1));      txy = [txy;[t(aux),p(aux),y(aux)]];   end   % Sorting the intersection points according to increasing t   [tt,I] = sort(txy(:,1));   txy = [tt,txy(I,2),txy(I,3)];   % Computing the intersection lengths and pixels.      % If the X-ray passes from corner to corner of the pixel, the corner   % coordinates appear twice. Discarding redundant intersections   % corresponding   % to pairs giving zeros (or negligible) intersection length.   is = length(txy(:,1));   lengths = txy(2:is,1) - txy(1:is-1,1);   xmids = 0.5*(txy(2:is,2) + txy(1:is-1,2));   ymids = 0.5*(txy(2:is,3) + txy(1:is-1,3));   iaux = find(lengths > eps);   lengths = lengths(iaux);   xmids = xmids(iaux);   ymids = ymids(iaux);    indx = ceil(N*xmids);   indy = ceil(N*(1-ymids));   new_index = index + length(iaux);   rows(index+1:new_index) = k*ones(length(iaux),1);   cols(index+1:new_index) = (indx-1)*N+indy;   vals(index+1:new_index) = lengths;   %ii = [ii;k*ones(length(iaux),1)];   %jj = [jj;(indx-1)*N+indy];   %vals = [vals;lengths];   index = new_index;endclose(h)ncut = min(find(isnan(vals)))-1;rows = rows(1:ncut);cols = cols(1:ncut);vals = vals(1:ncut);A = sparse(rows,cols,vals,K,N*N);return